# **JWT를 이용한 인증하기 (JWT, 인증)**  
# **학습 목표**  
다양한 인증 방법이 있지만 그중에서 가장 많이 사용되는 방법은 JWT(json web token) 토큰을 사용한 인증이다.  
  
# **사전 지식**  
# **인증**  
인증(authentication)은 서버와 통신하는 사용자의 정보와 유효성을 검증하는 기능이다. 18장의 드리프트 플러그인을 사용하여 
데이터베이스를 이용하는 형태의 캘린더 앱은 프론트엔드에서 흔히 사용하는 로컬 데이터베이스를 사용하고 있다. 즉 사용자의 
핸드폰에서 데이터베이스를 직접 관리하기 떄문에 사용 중인 하나의 핸드폰에 저장한 정보는 한 명의 사용자가 저장한 정보라고 
가정해도 무방하다.  
  
![img.png](image/img.png)  
  
사용자가 드리프트 API를 이용해 캘린더 앱에서 일정 관련 정보를 생성, 조회, 업데이트, 삭제한다. 드리프트 데이터베이스에서 새로 
입력받은 정보를 반영하거나 요청받은 정보를 반환한다. 이때 하나의 캘린더 앱당 드리프트 데이터베이스는 1:1로 매핑되어 있다. 
즉 하나의 앱당 데이터베이스는 하나다.  
  
하지만 앱에 서버를 연결하게 되면 상황은 매우 복잡하다. 19장에서 작업했던 캘린더 앱의 서버 연동 작업은 HTTP 프로토콜을 
통해 요청하는 법을 배우는 게 목표였기 때문에 사용자 정보 없이 직접 서버와 연동하는 작업을 했다. 다시 말해 단 하나의 기기만 
서버에 연동한다는 가정하에 작업하였다. 그렇기 떄문에 여러 기기에서 캘린더 앱을 실행하면 캘린더 앱을 실행한 모든 기기에서 
일정 데이터를 공유하게 된다. 개인 일정 관리를 목표로 기능을 만들었기 때문에 일정 데이터를 공유하는 것은 목적과 맞지 
않는다. 그러므로 A, B 사용자가 각각 생성한 개인 일정이 앱을 실행하면서 A, B 모두에게 공유된다면 개인 일정 앱이라고 볼 
수 없다.  
  
![img.png](image/img2.png)  
  
사용자 A와 사용자 B가 각각 다른 일정 A와 일정 B를 생성한다. 생성된 일정 A와 일정 B는 서버의 데이터베이스에 저장된다.  
  
![img.png](image/img3.png)  
  
사용자 A와 사용자 B가 각각 일정 정보를 서버에 요청한다. 요청을 받았지만 사용자를 식별할 수 있는 방법이 없어서 사용자 A와 
B는 일정 A와 일정 B 정보를 모두 응답받는다. 즉 본인이 생성한 일정뿐만 아니라 타인이 생성한 일정도 응답받게 된다.  
  
개인 일정 관리 앱의 일반적인 설계는 누가 생성한 일정인지 각 기기에 로그인한 사용자별로 구분하고 본인이 생성한 일정 정보만 
반환해주는 게 올바른 형태다. 이때 필요한 기능이 바로 인증이다. 특정 사용자로 로그인하고 로그인한 사용자의 정보를 기반으로 
일정을 생성하면 일정 정보를 요청할 때 요청하는 사용자가 생성한 일정만 구별해서 반환해준다.  
  
![img.png](image/img4.png)  
  
사용자 A와 사용자 B가 각각의 ID와 비밀번호를 입력해서 로그인한다. 로그인 정보를 기반으로 서버에서 사용자 인증을 진행하고 
인증 정보를 반환한다. 이 인증 과정에서 JWT를 사용한다.  
  
![img.png](image/img5.png)  
  
사용자 A와 사용자 B가 각각 다른 일정 A와 일정 B를 생성한다. 이때 사용자 A와 사용자 B는 인증 과정에서 발급받은 JWT를 
일정 데이터와 함께 전송한다. 일정 A와 일정 B를 저장할 때 각각의 일정 정보와 함께 전송된 JWT를 기반으로 어떤 사용자가 
생성한 일정인지에 대한 정보가 함께 데이터베이스에 저장된다.  
  
![img.png](image/img6.png)  
  
사용자 A와 사용자 B가 각각 일정 정보를 서버에 요청한다. 이때 인증 정보가 있는 JWT 토큰과 함게 요청을 보낸다. 서버에서는 
JWT를 분석하여 어떤 사용자가 요청을 보냈는지 알 수 있다. 서버에 생성된 일정은 어떤 사용자가 생성한 일정인지 이미 구분되어 
저장되어 있다. 일정 데이터 생성에서 JWT를 전송하여 인증 정보를 바탕으로 정보가 저장되었기 떄문이다. 따라서 각 사용자별로 
본인이 생성한 일정만 응답받을 수 있다.  
  
# **JWT란?**  
어떤 사용자가 요청을 하는지 알기 위해서 요청을 보낼 때마다 사용자에게 ID와 비밀번호를 입력하게 한다면 최악의 UX를 갖게 
하는 앱을 제작하게 될 것이다. 그렇기 때문에 사용자가 한 번 로그인을 하면 요청을 보낼 때마다 ID와 비밀번호를 매번 입력할 
필요 없이 기입력된 사용자 정보를 서버로 전달할 방법이 필요하다. 현대에는 이런 번거로움을 줄이기 위해 보편적으로 JWT를 
사용해서 사용자 정보를 서버와 공유한다.  
  
JWT는 헤더(header), 페이로드(payload), 시그니처(signature) 세 가지 요소로 이루어져 있다. 이 세 가지 요소를 이용해서 
토큰의 정보, 사용자 정보 그리고 토큰의 유효성에 대한 정보를 담게 된다. 이 세 요소는 각각 URL에 전송 가능한 형태인 
URL base64로 인코딩되어 있으며 '.'을 이용하여 하나의 String 값으로 묶어서 사용한다.  
  
![img.png](image/img7.png)  
![img.png](image/img8.png)  
  
헤더에는 토큰에 대한 정보가 담긴다. 예를 들면 토큰의 시그니처가 어떤 알고리즘으로 암호화됐는지, 토큰의 타입이 무엇인지 
저장한다.  
  
페이로드에는 데이터베이스상의 사용자 ID, 사용자 이름, 토큰의 만료 기간 등 사용자 정보가 담긴다.  
  
시그니처에는 JWT의 유효성을 검증할 수 있는 정보가 담겨 있다. 토큰을 생성할 당시 헤더를 base64로 인코딩한 값과 페이로드를 
base64로 인코딩한 값 그리고 사용자가 지정한 Secret값을 모두 합쳐서 헤더에서 정한 알고리즘으로 암호화한다. 만약 인증하는 
과정에서 해커가 JWT를 탈취한 후 페이로드나 헤더값을 한 글자라도 변경하면 똑같은 알고리즘으로 암호화한다 해도 다른 시그니처값이 
반환된다. 이 변경된 시그니처값과 기존의 시그니처값 대조를 통해 토큰의 변형 여부를 알 수 있다. 그렇기 때문에 Secret 값은 
탈취되지 않고 JWT가 탈취되어 토큰 내부 정보가 변경된다면 토큰의 변형 여부를 시그니처값 대조를 통해 알 수 있으므로 서버 
요청에 사용할 수 없다.  
  
# **액세스 토큰과 리프레시 토큰**  
JWT를 이용한 인증은 액세스 토큰과 리프레시 토큰 두 가지를 사용하는 방법이 일반적이다. 액세스 토큰은 보호된 정보에 접근할 
수 있는 권한 부여에 사용된다. 서버에 인증 정보를 보내서 리소스를 가져오거나 변경, 생성, 삭제하는데 이용할 수 있다. 
리프레시 토큰은 액세스 토큰의 유효기간이 만료됐을 때 재발급받을 수 있도록 사용하는 특수한 토큰이다.  
  
액세스 토큰은 사용 빈도가 높아 탈취당할 가능성이 매우 큰 토큰이다. 만약 해커가 액세스 토큰을 탈취하면 해당 액세스 토큰의 
사용자인 척하며 서버에 정보를 요청할 수 있다. 그래서 액세스 토큰은 탈취되어도 해커가 오래 사용하지 못하도록 액세스 토큰 
자체의 유요기간을 짧게 지정하여 문제를 해결한다.  
  
리프레시 토큰은 액세스 토큰을 폐기하고 새로운 액세스 토큰을 발급받을 때 사용한다. 물론 해커가 리프레시 토큰을 탈취하면 
액세스 토큰을 무한하게 발급받을 수 있다. 하지만 리프레시 토큰은 액세스 토큰과 비교했을 때 자주 사용하지 않아서 탈취당할 
가능성이 낮다.  
  
이렇게 탈취당할 확률이 높은 액세스 토큰은 유효기간을 짧게 지정하고 탈취당할 확률이 낮은 리프레시 토큰은 유효기간을 길게 
줘서 보안을 챙긴다.  
  
# **JWT를 이용한 인증 절차**  
JWT 인증 절차는 다음 세 가지 상황만 이해하면 된다. 첫 번쨰로 토큰을 발급받는 과정이다. 사용자가 ID와 비밀번호를 입력하고 
리프레시 토큰과 액세스 토큰을 발급받는다. 두 번째는 엑세스 토큰을 사용할 때이다. 액세스 토큰을 이용하여 사용자 정보와 
함께 서버에 요청을 보낸다. 마지막으로 유효기간이 만료된 액세스 토큰을 서버에 요청보낸 상황이다. 만료된 액세스 토큰을 
받은 서버는 요청을 받아들이지 않으며 401 에러가 발새한다. 이를 기반으로 사용자는 리프레시 토큰을 이용하여 액세스 토큰을 
재발급받고 새로운 토큰으로 기존 요청을 다시 보낸다.  
  
![img.png](image/img9.png)  
  
아이디와 비밀번호를 서버로 전송한다. 이때 아이디와 비밀번호는 ID:PASSWORD 형태로 base64로 인코딩한 다음 헤더에 authorization: 
'Basic {인코딩한 결과}' 형태로 전송한다. 헤더에 넣어준 정보를 서버에서 base64 인코딩한 후 아이디와 비밀번호를 검증한다. 
아이디와 비밀번호 검증에 성공하면 리프레시 토큰과 액세스 토큰을 응답으로 보내준다.  
  
![img.png](image/img10.png)  
  
헤더에 액세스 토큰을 authorization: 'Bearer {토큰}' 형태로 포함해서 API 요청을 한다. 그 후 액세스 토큰의 유효성을 검증하고 
액세스 토큰을 기반으로 데이터를 응답해준다.  
  
![img.png](image/img11.png)  
  
API 요청을 보낼 때 유효기간이 만료된 액세스 토큰을 함께 보낸다. 서버에서 액세스 토큰을 검증하지만 만료된 토큰이다. 서버는 
상태 코드 401 에러를 응답하며 만료된 토큰임을 알린다. 사용자는 리프레시 토큰을 포함하여 헤더에 authorization: 'Bearer {토큰}' 
을 입력해서 액세스 토큰 재발급을 URL에 요청보낸다. 서버에서 리프레시 토큰을 검증하고 새로운 액세스 토큰을 발급한다. 
신규 액세스 토큰을 응답으로 보내주고 새로운 액세스 토큰을 이용해서 이전에 실패한 요청을 다시 보낸다. 서버에서 액세스 토큰을 
검증하고 검증된 액세스 토큰을 기반으로 응답을 보내준다.  
  
# **사전 준비**  
# **서버 프로젝트 실행**  
1. Terminal 탭에서 npm run start:dev를 실행한다. 정상적으로 서버가 실행되면 서버 라우트 매핑과 관련된 로그가 출력된다.  
  
# **플러터 템플릿 프로젝트 설치**  
19장에서 서버와 연동하기에서 구현해놓은 프로젝트에 인증 기능을 추가하는 방식으로 진행한다.  
  
# **레이아웃 구상하기**  
이번 프로젝트에 추가할 UI는 로그인/회원가입 스크린이다. 실제 상업용 앱을 제작한다면 로그인과 회원가입 화면을 따로 만들고 
각종 검증 과정도 추가해야 한다.  
  
# **회원가입/로그인 페이지 구상하기**  
일정 생성 과정과 마찬가지로 텍스트 필드를사용하여 이메일과 비밀번호를 입력받는다. 회원가입 버튼을 누르면 입력된 이메일과 
비밀번호를 기반으로 회원가입을 진행한다. 로그인 버튼을 누르면 로그인을 진행한다.  
  
![img.png](image/img12.png)  
  
# **구현하기**  
# **로그인 UI 구현하기**  
1. 로그인/회원가입 UI를 제작할 때 사용할 로고를 pubspec.yaml 파일에 assets을 등록해준다. assets의 주석 처리를 해제하고 
그 아래에 원하는 폴더를 지정해준다. pubspec.yaml을 수정하고 pub get을 클릭해 실행해준다.  
  
pubspec.yaml 참고  
  
2. lib/screen/auth_screen.dart 파일을 생성한다. 이 파일에 로그인 관련 UI를 작성한다.  
  
3. 로그인 UI를 제작할 StatefulWidget을 생성한다. 로그인/회원가입과 관련된 모든 로직을 수행할 UI이기 때문에 AuthScreen이라고 
부르도록 한다.  
  
lib -> screen -> auth_screen.dart  
  
4. 로고와 텍스트 필드 그리고 회원가입 및 로그인 버튼은 모두 세로 방향으로 순서대로 배치한다. build() 함수를 모두 수정한다.  
  
lib -> screen -> auth_screen.dart  
  

