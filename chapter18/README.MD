# **데이터베이스 연동하기(SQL, SQLite, Drift, Dismissible)**  
# **프로젝트 구상하기**  
18장에서는 로컬 데이터베이스로 SQLite를 사용한다. SQLite를 잘 사용하려면 SQL 문법을 알아야 한다. 드리프트를 이용해서 
SQLite 테이블 및 모델을 형성하고 데이터를 삽입, 업데이트, 조회하기 때문에 직접 SQL문을 작성할 일은 없지만 기초 SQL은 
알아두는 것이 좋다.  
  
# **사전 지식**  
# **SQL, SQLite**  
SQL은 Standard Query Language의 약자로 데이터베이스 언어이다. SQL은 데이터베이스별로 문법이 약간씩은 다르지만 큰 
틀은 공유한다. 서버에서 사용하는 데이터베이스로는 MySQL, 오라클, 포스트그레SQL, DB2, SQL 서버 등이 있다. 이번에 다룰 
SQLite는 프론트엔드에서 흔히 사용하는 데이터베이스이다. 이름에서도 볼 수 있듯이 SQL을 사용하는 비교적 가벼운 데이터베이스다.  
  
이번 프로젝트는 드리프트(Drift)라는 패키지를 사용한다. 그래서 SQL을 직접적으로 사용하진 않겠지만 SQL을 어느 정도 알고 
있어야 드리프트 패키지를 이해하기 쉽다.  
  
# **드리프트 플러그인**  
드리프트 플러그인을 사용하면 직접 SQL을 작성하지 않고도 SQLite를 사용할 수 있다. SQLite 쿼리를 직접 작성할 수도 있지만 
그럴 경우 모든 쿼리를 String으로 작업해야 해서 유지보수가 힘들다. 그래서 드리프트와 같은 객체-관계 모델을 사용한다. 
테이블을 클래스로 표현하고 쿼리를 다트 언어로 표현하면 드리프가 자동으로 해당되는 테이블과 쿼리를 생성한다.  
  
![img.png](imgae/img.png)  
![img.png](imgae/img2.png)  
![img.png](imgae/img3.png)  
![img.png](imgae/img4.png)  
  
# **Dismissible 위젯**  
Dismissible 위젯은 위젯을 밀어서 삭제하는 기능을 제공한다. 밀어서 삭제하기를 구현하고 싶은 위젯을 Dismissible 위젯으로 
감싸고 onDismissed와 key 매개변수를 입력해주면 된다.  
  
![img.png](imgae/img5.png)  
  
아래 표는 삭제 방향을 표현하는 DismissDirection enum의 값들을 정리한 표다.  
  
![img.png](imgae/img6.png)  
  
# **구현하기**  
드리프트 설정부터 진행한다. SQLite 데이터베이스를 사용하려면 가장 먼저 테이블을 생성해야 한다. 드리프트로 테이블을 
생성하고 테이블에 데이터를 조회, 삽입, 업데이트, 삭제하는 기능을 만든다. 마지막으로 17장에서 구현한 UI와 18장에서 
구현한 기능을 연동해서 로컬데이터베이스를 사용하는 일정 앱을 완성한다.  
  
# **모델 구현하기**  
데이터베이스를 설계할 때 모델을 구현하는 일이 중요하다. 개별 테이블을 잘 만들고 잘 연동되도록 설계해야 손쉽게 SQLite를 
사용할 수 있다. 이 책에서는 직접 SQLite를 사용하지 않고 코드를 이용해 데이터베이스를 사용할 수 있는 드리프트를 사용해 
작업한다.  
  
1. lib/model/schedule.dart 파일을 생성해서 테이블을 생성한다. 드리프트를 사용하면 클래스를 선언해서 테이블을 생성할 
수 있다. 테이블은 드리프트 패키지의 Table 클래스를 상속하면 선언할 수 있다. 그다음 자식 클래스에 열로 정의하고 싶은 
값들을 게터로 선언해주면 된다. 열 선언은 세 가지 요소로 나뉘어진다. 열의 타입, 열의 이름, 열의 속성이다. 열의 타입으로는 
IntColumn, TextColumn, DateTimeColumn 등이 있다. 이름 그대로 어떤 타입의 열인지를 정의할 수 있으며 SQLite에 존재하는 
열 타입들을 모두 사용할 수 있다. 열 이름은 일반적으로 클래스에서 게터를 선언하듯이 작성하면 된다. 열 속성은 무조건 열의 
타입으로부터 시작된다. 그다음 추가하고 싶은 속성이 있다면 함수를 이어서 실행해주면 된다. 다음 코드의 1을 예로 들면 
Integer 타입의 id 열에 AUTOINCREMENT 속성을 추가한다. 모든 속성을 추가했으면 괄호를 여닫으며 함수를 한 번 더 실행해준다. 
그래야 선언한 모든 속성들이 SQL 문법으로 전환된다.  
  
![img.png](imgae/img7.png)  
  
lib -> model -> schedule.dart  
  
# **테이블 관련 코드 생성하기**  
드리프트에 생성한 Schedules 테이블을 등록해주면 드리프트가 자동으로 테이블과 관련된 기능을 코드로 생성한다. 이렇게 작성한 
코드를 기반으로 자동으로 코드가 생성되는 걸 코드 생성(code generation)이라고 한다.  
  
1. 어떤 플러터 패키지에서든 코드 생성을 사용하려면 part 파일을 지정해줘야 한다. part 파일은 part 키워드를 사용해서 
지정하면 된다. 코드 생성을 사용하는 각각 패키지별로 part 파일의 이름 패턴은 약간 다르지만 대부분은 현재 파일 이름에 
.g.dart를 추가하는 형식이다. 드리프트 또한 현재 파일명에 .g.dart를 추가하면 된다. 해당 파일이 아직 존재하지 않을 때 
코드 생성을 실행하면 자동으로 생성된다.  
  
lib -> database -> drift_database.dart  
  
드리프트 관련 쿼리를 작성할 클래스를 하나 작성하고 이 클래스의 이름 앞에 _$를 추가한 부모 클래스를 상속한다. 이 클래스는 
현재 존재하지 않지만 코드 생성을 실행하면 생성된다.  
  
part 파일은 import와 비슷한 기능을 갖고 있다. part 파일로 파일을 지정하면 해당 파일의 값들을 현재 파일에서 사용할 수 
있게 된다. 하지만 public 값들만 사용할 수 있는 import 기능과 달리 part 파일은 private값들도 사용할 수 있다.  
  
2. 이제 코드 생성을 통해 쿼리를 작성하는 데 필요한 기능을 생성해야 한다. 안드로이드 스튜디오 하단에서 terminal 탭을 
눌러서 현재 프로젝트 위치에서 terminal 또는 CMD를 실행 후 flutter pub run build_runner build 명령어를 실행해서 
코드 생성을 진행한다.  
  
명령어 실행 후 프로젝트를 보면 database 폴더에 생성하지 않은 파일이 새로 생긴 걸 볼 수 있다. drift_database.g.dart 
파일을 열어보면 굉장히 많은 코드가 자동으로 작성되어 있다. 이 파일 안에는 상속한 _$LocalDatabase 클래스도 있다.  
  
# **쿼리 구현하기**  
1. 코드 생성을 실행하면 테이블과 관련된 쿼리를 작성하는 데 필요한 기능이 모두 생성된다. 자동으로 생성된 코드를 사용해서 
일정들을 불러오는 SELECT 기능을 먼저 작업한다. 드리프트에서 SELECT 기능을 두 가지로 표현할 수 있다. 일회성으로 데이터를 
가져오는 get() 함수와 변화가 있을 때마다 자동으로 데이터를 불러오는 watch() 함수이다. 일반적으로 get() 함수는 버튼을 
눌렀을 때처럼 특정 상황의 데이터를 가져올 때 사용되고 watch() 함수는 위젯처럼 데이터가 업데이트될 때마다 새로운 값을 
반영해줘야 할 때 사용된다. 달력에서 특정 날짜를 선택했을 때 해당되는 일정을 불러오는 기능을 만들어야 하니 watch() 함수로 
SELECT 기능을 구현한다.  
  
lib -> database -> drift_database.dart  
  
괄호가 많아서 헷갈릴 수 있지만 하나씩 분리하면 크게 어려운 코드가 아니다. 코드 생성을 통해 생성된 클래스에는 SQL SELECT문에 
해당되는 select() 함수가 주어진다. 이 함수가 반환하는 값은 watch() 또는 get() 함수를 실행할 수 있다. 하지만 모든 일정을 
다 불러오는 게 아니고 특정 날짜에 해당되는 일정만 불러오기 떄문에 where 함수를 통해서 관련 일정을 먼저 필터링해야 한다. 
결론적으로 where() 함수가 아닌 select() 함수에 watch() 함수가 직접 실행되어야 하기 떄문에 괄호가 한 번 더 감싸진 
형태이다.  
  
추가적으로 where() 함수에 제공되는 첫 번쨰 매개변수에는 현재 선택한 테이블에 해당되는 값이 제공된다. 드리프트로 필터링을 
진행할 때는 다트 언어에서 일반적으로 사용하는 == 또는 < 같은 비교 기호를 사용하지 않고 테이블 객체에서 제공하는 함수로 
비교를 진행해야 한다. 테이블의 date 컬럼과 매개변수에 입력된 date 변수가 같은지 비교하기 위해 equals() 함수를 사용했다.  
  
2. 이번에는 INSERT에 해당하는 새로운 일정을 생성하는 기능을 구현한다. select() 함수가 코드 생성을 통해서 제공된 것처럼 
insert() 함수도 제공된다. 다만 select() 함수와 비교해서 특이한 점은 into() 함수를 먼저 사용해서 어떤 테이블에 데이터를 
넣을지 지정해준 다음 insert() 함수를 이어서 사용해야 한다는 점이다. 추가적으로 코드 생성을 실행하면 모든 테이블의 
Companion 클래스가 생성된다. 데이터를 생성할 때는 꼭 생성된 Companion 클래스를 통해서 값들을 넣어줘야 하기 때문에 
Schedules 테이블에 해당되는 SchedulesCompanion 클래스를 입력받아서 insert() 함수에 전달해준다.  
   
lib -> databaase -> drift_database.dart  
  
3. 마지막으로 일정을 삭제하는 기능을 구현한다. select(), insert() 함수와 마찬가지로 코드 생성에서 제공하는 delete() 
함수를 사용해서 구현한다. select() 함수에서 watch() 함수와 get() 함수를 실행하듯이 delete() 함수에는 go() 함수를 
실행해줘야 삭제가 완료됩니다. 추가적으로 유의할 점은 특정 ID에 해당되는 값만 삭제해야 하니 매개변수에 id값을 입력받고 해당 
id에 해당되는 일정만 삭제해야 한다.  
  
4. 드리프트 데이터베이스 클래스는 필수로 schemaVersion값을 지정해줘야 한다. 기본적으로 1부터 시작하고 테이블의 변화가 
있을 때마다 1씩 올려줘서 테이블 구조가 변경된다는 걸 드리프트에 인지시켜주는 기능이다.  
  
lib -> database -> drift_database.dart  
  
5. 마지막으로 데이터베이스 파일을 생성하고 연동한다. 드리프트 데이터베이스 객체는 부모 생성자에 LazyDatabase를 필수로 
넣어야 한다. LazyDatabase 객체에는 데이터베이스를 생성할 위치에 대한 정보를 입력해주면 된다.  
  
lib -> database -> drift_database.dart  
  
안드로이드와 iOS 플랫폼 모두 각 앱별로 사용할 수 있는 전용 폴더를 제공받는다. SQLite는 파일 기반으로 데이터를 저장하기 
때문에 필수적으로 데이터베이스의 파일 위치를 제공해줘야 한다. path_provider 패키지에서 제공하는 getApplicationDocumentsDirectory() 
함수를 사용하면 현재 앱이 배정된 폴더의 경로를 받을 수 있다. 해당 폴더에 db.sqlite라는 파일을 데이터베이스 파일로 
사용한다.  
  
# **드리프트 초기화하기**  
1. 드리프트 설정을 마쳤으니 구현한 기능들을 프로젝트에서 사용하도록 초기화한다.  
  
lib -> main.dart  
  
미리 정의해둔 LocalDatabase 클래스를 인스턴스화한다. get_it 패키지는 Dependency Injection, 즉 의존성 주입을 구현하는 
플러그인이다. 위에서 선언한 database 클래스를 프로젝트 전역에서 사용할 수 있어야 하는데 서브 위젯으로 값을 계속 넘겨주기에는 
반복적인 코드를 너무 많이 사용해야 한다. GetIt으로 값을 한 번 등록해두면 어디서든 처음에 주입한 값 즉 같은 database 변수를 
GetIt.I를 통해서 프로젝트 어디서든 사용할 수 있다.  
  
